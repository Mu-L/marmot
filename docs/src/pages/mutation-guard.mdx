---
title: MutationGuard Protocol
---

# MutationGuard Protocol

MutationGuard is an optimization layer on top of traditional MVCC that enables early conflict detection in Marmot's distributed transaction protocol. By detecting write-write conflicts before replication begins, it reduces wasted work and improves throughput for concurrent write-heavy workloads.

## Why MutationGuard?

### The Problem with Pure MVCC

In traditional MVCC-based distributed databases, write conflicts are detected at commit time. Consider two concurrent transactions updating the same rows:

```
T1: UPDATE users SET balance = balance - 100 WHERE id = 5
T2: UPDATE users SET balance = balance + 50 WHERE id = 5

Timeline:
  T1 begins at ts=100
  T2 begins at ts=101
  T1 replicates to all nodes
  T2 replicates to all nodes
  T2 discovers conflict at commit time → ABORT
```

The problem: T2 did all the work of replicating to every node, only to be aborted. In a cluster with N nodes, this wastes N-1 network round trips.

### Early Conflict Detection

MutationGuard shifts conflict detection to the PREPARE phase:

```
T1: UPDATE users SET balance = balance - 100 WHERE id = 5
T2: UPDATE users SET balance = balance + 50 WHERE id = 5

Timeline:
  T1 begins at ts=100, builds guard for row id=5
  T2 begins at ts=101, builds guard for row id=5
  T1 sends PREPARE with guard
  T2 sends PREPARE with guard → CONFLICT detected immediately
  T2 aborts before any replication work
  T1 proceeds to commit
```

The benefit: T2 fails fast, before consuming network bandwidth across the cluster.

---

## Design Goals

<svg viewBox="0 0 800 160" className="w-full my-8" style={{maxWidth: '800px'}}>
  <rect x="20" y="20" width="180" height="120" rx="8" fill="#1e1b4b" stroke="#22c55e" strokeWidth="2"/>
  <text x="110" y="50" textAnchor="middle" fill="#22c55e" fontSize="13" fontWeight="bold">Zero False Positives</text>
  <text x="110" y="75" textAnchor="middle" fill="#a5b4fc" fontSize="11">Exact hash comparison</text>
  <text x="110" y="95" textAnchor="middle" fill="#a5b4fc" fontSize="11">No probabilistic errors</text>
  <text x="110" y="115" textAnchor="middle" fill="#a5b4fc" fontSize="11">Deterministic detection</text>

  <rect x="220" y="20" width="180" height="120" rx="8" fill="#1e1b4b" stroke="#6366f1" strokeWidth="2"/>
  <text x="310" y="50" textAnchor="middle" fill="#818cf8" fontSize="13" fontWeight="bold">Efficient Multi-Row</text>
  <text x="310" y="75" textAnchor="middle" fill="#a5b4fc" fontSize="11">Single payload per table</text>
  <text x="310" y="95" textAnchor="middle" fill="#a5b4fc" fontSize="11">O(1) intersection check</text>
  <text x="310" y="115" textAnchor="middle" fill="#a5b4fc" fontSize="11">Hash set comparison</text>

  <rect x="420" y="20" width="180" height="120" rx="8" fill="#1e1b4b" stroke="#f59e0b" strokeWidth="2"/>
  <text x="510" y="50" textAnchor="middle" fill="#fcd34d" fontSize="13" fontWeight="bold">Graceful Fallback</text>
  <text x="510" y="75" textAnchor="middle" fill="#a5b4fc" fontSize="11">Configurable threshold</text>
  <text x="510" y="95" textAnchor="middle" fill="#a5b4fc" fontSize="11">MVCC for large batches</text>
  <text x="510" y="115" textAnchor="middle" fill="#a5b4fc" fontSize="11">No memory explosion</text>

  <rect x="600" y="20" width="180" height="120" rx="8" fill="#1e1b4b" stroke="#ec4899" strokeWidth="2"/>
  <text x="690" y="50" textAnchor="middle" fill="#f472b6" fontSize="13" fontWeight="bold">SQLite-Friendly</text>
  <text x="690" y="75" textAnchor="middle" fill="#a5b4fc" fontSize="11">Works with single-writer</text>
  <text x="690" y="95" textAnchor="middle" fill="#a5b4fc" fontSize="11">Preupdate hook capture</text>
  <text x="690" y="115" textAnchor="middle" fill="#a5b4fc" fontSize="11">WAL mode compatible</text>
</svg>

---

## How It Works

### Transaction Flow

<svg viewBox="0 0 800 200" className="w-full my-8" style={{maxWidth: '800px'}}>
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
      <path d="M0,0 L0,6 L9,3 z" fill="#6366f1"/>
    </marker>
  </defs>
  <rect x="20" y="60" width="160" height="80" rx="8" fill="#1e1b4b" stroke="#6366f1" strokeWidth="2"/>
  <text x="100" y="95" textAnchor="middle" fill="#e0e7ff" fontSize="14" fontWeight="bold">Coordinator</text>
  <text x="100" y="115" textAnchor="middle" fill="#a5b4fc" fontSize="11">Execute locally</text>
  <text x="100" y="130" textAnchor="middle" fill="#a5b4fc" fontSize="11">Build hash sets</text>

  <rect x="320" y="20" width="160" height="60" rx="8" fill="#1e1b4b" stroke="#6366f1" strokeWidth="2"/>
  <text x="400" y="45" textAnchor="middle" fill="#e0e7ff" fontSize="14" fontWeight="bold">Replica 1</text>
  <text x="400" y="65" textAnchor="middle" fill="#a5b4fc" fontSize="11">Check conflicts</text>

  <rect x="320" y="120" width="160" height="60" rx="8" fill="#1e1b4b" stroke="#6366f1" strokeWidth="2"/>
  <text x="400" y="145" textAnchor="middle" fill="#e0e7ff" fontSize="14" fontWeight="bold">Replica 2</text>
  <text x="400" y="165" textAnchor="middle" fill="#a5b4fc" fontSize="11">Check conflicts</text>

  <rect x="600" y="60" width="160" height="80" rx="8" fill="#1e1b4b" stroke="#22c55e" strokeWidth="2"/>
  <text x="680" y="95" textAnchor="middle" fill="#e0e7ff" fontSize="14" fontWeight="bold">Quorum</text>
  <text x="680" y="115" textAnchor="middle" fill="#86efac" fontSize="11">2 of 3 nodes</text>
  <text x="680" y="130" textAnchor="middle" fill="#86efac" fontSize="11">Commit</text>

  <line x1="180" y1="80" x2="315" y2="50" stroke="#6366f1" strokeWidth="2" markerEnd="url(#arrow)"/>
  <line x1="180" y1="120" x2="315" y2="150" stroke="#6366f1" strokeWidth="2" markerEnd="url(#arrow)"/>
  <line x1="485" y1="50" x2="595" y2="85" stroke="#22c55e" strokeWidth="2" markerEnd="url(#arrow)"/>
  <line x1="485" y1="150" x2="595" y2="115" stroke="#22c55e" strokeWidth="2" markerEnd="url(#arrow)"/>

  <text x="250" y="55" textAnchor="middle" fill="#a5b4fc" fontSize="10">PREPARE</text>
  <text x="250" y="165" textAnchor="middle" fill="#a5b4fc" fontSize="10">+hashes</text>
  <text x="545" y="75" textAnchor="middle" fill="#86efac" fontSize="10">ACK</text>
  <text x="545" y="140" textAnchor="middle" fill="#86efac" fontSize="10">ACK</text>
</svg>

1. **Local Execution**: Coordinator executes SQL locally with hooks capturing every modified row
2. **Hash Set Construction**: Primary keys are serialized into row keys, then hashed with XXH64
3. **PREPARE Phase**: Hash sets sent to replicas for conflict checking
4. **Conflict Detection**: Replicas check for intersection with existing guards
5. **COMMIT Phase**: On quorum ACK, coordinator commits and broadcasts to finalize

---

## Row Key Serialization

Row keys uniquely identify each row for conflict detection. The serialization format must be:
- **Deterministic**: Same row always produces same key
- **Collision-free**: Different rows never produce same key
- **Efficient**: Fast to serialize and hash

### Single-Column Primary Keys

For tables with a single primary key column:

| PK Type | Format | Example |
|---------|--------|---------|
| Numeric | `table:value` | `users:12345` |
| Non-numeric | `table:b64:<base64>` | `users:b64:am9obg==` |

Numeric values are stored directly (faster). Non-numeric values are base64-encoded to handle special characters like `:` that could cause parsing ambiguity.

### Composite Primary Keys

Tables with multi-column primary keys require special handling to ensure deterministic, collision-free serialization.

**Key Insight**: Column order must be canonical. If two transactions serialize columns in different orders, identical rows would hash differently, causing false negatives (missed conflicts).

**Solution**: Columns are sorted alphabetically by name before serialization.

| Table | PK Columns | Row Values | Sorted Order | Row Key |
|-------|------------|------------|--------------|---------|
| `order_items` | `order_id`, `product_id` | `100`, `5` | `order_id`, `product_id` | `order_items:c:MTAw:NQ==` |
| `user_roles` | `role_id`, `user_id` | `admin`, `42` | `role_id`, `user_id` | `user_roles:c:YWRtaW4=:NDI=` |

**Format**: `table:c:<b64_col1>:<b64_col2>:...`

The `c:` prefix indicates composite key. All values are base64-encoded regardless of type to ensure consistent handling.

### NULL Handling

NULL values in primary keys use a sentinel value `\x00NULL\x00` to distinguish from:
- Empty strings (`""`)
- The literal string `"NULL"`

This prevents collisions between `(id=1, name=NULL)` and `(id=1, name="")`.

---

## XXH64 Hashing

Once row keys are serialized, they're hashed using XXH64:

| Property | Value |
|----------|-------|
| **Hash size** | 64 bits (8 bytes) |
| **Collision probability** | ~5.4 × 10⁻²⁰ per pair |
| **Speed** | ~10 GB/s on modern CPUs |
| **False positive rate** | 0% (exact match) |

### Why XXH64?

1. **Speed**: Among the fastest non-cryptographic hashes
2. **Quality**: Excellent distribution, no known weaknesses
3. **Simplicity**: Single 64-bit value, trivial to compare
4. **Maturity**: Battle-tested in production systems

### Storage Efficiency

| Rows Modified | Hash Set Size | Network Overhead |
|---------------|---------------|------------------|
| 100 | 800 bytes | 1 packet |
| 1,000 | 8 KB | 6 packets |
| 10,000 | 80 KB | ~55 packets |
| 64,000 | 512 KB | ~350 packets |

---

## Conflict Detection Algorithm

### Hash Set Intersection

Conflict detection reduces to set intersection. Given two hash sets A and B:

```
Conflict exists if A ∩ B ≠ ∅
```

Using hash maps (`map[uint64]struct{}`), intersection checking is O(min(|A|, |B|)):
- Iterate over the smaller set
- Check membership in the larger set
- Stop on first match (conflict found)

### Wound-Wait Deadlock Prevention

When conflicts are detected, Marmot uses the Wound-Wait protocol:

<svg viewBox="0 0 700 160" className="w-full my-8" style={{maxWidth: '700px'}}>
  <rect x="20" y="20" width="300" height="120" rx="12" fill="#0f172a" stroke="#22c55e" strokeWidth="2"/>
  <text x="170" y="50" textAnchor="middle" fill="#22c55e" fontSize="14" fontWeight="bold">Older Wins (Wound)</text>
  <text x="40" y="80" fill="#e0e7ff" fontSize="12">T1 (ts=100) vs T2 (ts=200)</text>
  <text x="40" y="105" fill="#a5b4fc" fontSize="12">T1 proceeds, T2 aborted</text>
  <text x="40" y="130" fill="#86efac" fontSize="11">Older transaction always wins</text>

  <rect x="380" y="20" width="300" height="120" rx="12" fill="#0f172a" stroke="#f59e0b" strokeWidth="2"/>
  <text x="530" y="50" textAnchor="middle" fill="#f59e0b" fontSize="14" fontWeight="bold">Younger Waits</text>
  <text x="400" y="80" fill="#e0e7ff" fontSize="12">T2 (ts=200) arrives after T1</text>
  <text x="400" y="105" fill="#a5b4fc" fontSize="12">T2 waits or retries</text>
  <text x="400" y="130" fill="#fcd34d" fontSize="11">No deadlocks possible</text>
</svg>

**Guarantee**: No deadlocks. Transactions are totally ordered by timestamp, and older always wins.

---

## Large Transaction Handling

MutationGuard is optimized for typical OLTP workloads (hundreds to thousands of rows). For bulk operations, hash sets become expensive:

| Rows | Hash Set Size | Issue |
|------|---------------|-------|
| 100K | 800 KB | Network congestion |
| 1M | 8 MB | Memory pressure |
| 10M | 80 MB | Impractical |

### MVCC Fallback

Transactions exceeding `max_guard_rows` (default: 65,536) skip MutationGuard entirely:

1. Hash sets are not built for that table
2. PREPARE proceeds without early conflict detection
3. Conflicts detected at commit time via MVCC write intents
4. Slightly higher latency, but no memory explosion

This hybrid approach provides:
- Fast conflict detection for typical transactions
- Safe handling of bulk operations
- Configurable threshold based on cluster resources

---

## Comparison with Alternatives

### Per-Row Write Intents (TiDB, CockroachDB)

Traditional approach: Each modified row gets a write intent record.

| Aspect | Per-Row Intents | MutationGuard |
|--------|-----------------|---------------|
| Storage | O(N) records | O(N) bytes (8/row) |
| Network | O(N) RPCs | O(1) RPC per table |
| Conflict detection | At commit time | At PREPARE time |
| Memory | Proportional to rows | Bounded by threshold |

### Lock Tables (Spanner)

Spanner uses lock tables for serializability.

| Aspect | Lock Tables | MutationGuard |
|--------|-------------|---------------|
| Complexity | High (lock management) | Low (hash sets) |
| Latency | Higher (lock acquisition) | Lower (no locks) |
| Deadlocks | Possible, needs detection | Impossible (Wound-Wait) |

### Why Hash Sets?

MutationGuard's approach is particularly suited to Marmot's architecture:

1. **SQLite's single-writer model** means conflicts are between concurrent prepare phases, not concurrent writes to the same database
2. **Leaderless replication** means any node can coordinate, so lightweight conflict detection is essential
3. **Bounded memory** via threshold ensures predictable resource usage

---

## Configuration

```toml
[coordinator]
# Maximum rows per transaction for hash set guards
# Larger transactions use MVCC fallback
# Default: 65536 (64K rows, ~512KB payload)
max_guard_rows = 65536

# TTL for guards (milliseconds)
# Guards expire after this time if coordinator crashes
# Default: 60000 (60 seconds)
intent_ttl_ms = 60000

# Timeout for abort messages (milliseconds)
# Default: 2000 (2 seconds)
abort_timeout_ms = 2000
```

### Tuning Guidelines

| Scenario | max_guard_rows | Rationale |
|----------|----------------|-----------|
| Memory-constrained | 16384 | More MVCC fallback, less memory |
| Standard deployment | 65536 | Balanced (default) |
| High-memory, fast network | 131072 | More early detection |

---

## Summary

MutationGuard provides early conflict detection as an optimization layer on MVCC:

<svg viewBox="0 0 800 140" className="w-full my-8" style={{maxWidth: '800px'}}>
  <rect x="20" y="20" width="370" height="100" rx="8" fill="#1e1b4b" stroke="#22c55e" strokeWidth="2"/>
  <text x="205" y="50" textAnchor="middle" fill="#22c55e" fontSize="14" fontWeight="bold">Benefits</text>
  <text x="40" y="75" fill="#a5b4fc" fontSize="12">Early conflict detection reduces wasted replication</text>
  <text x="40" y="95" fill="#a5b4fc" fontSize="12">Zero false positives via exact hash comparison</text>
  <text x="40" y="115" fill="#a5b4fc" fontSize="12">Configurable threshold with MVCC fallback</text>

  <rect x="410" y="20" width="370" height="100" rx="8" fill="#1e1b4b" stroke="#6366f1" strokeWidth="2"/>
  <text x="595" y="50" textAnchor="middle" fill="#818cf8" fontSize="14" fontWeight="bold">Key Design Choices</text>
  <text x="430" y="75" fill="#a5b4fc" fontSize="12">XXH64 for speed and quality</text>
  <text x="430" y="95" fill="#a5b4fc" fontSize="12">Alphabetically sorted composite keys</text>
  <text x="430" y="115" fill="#a5b4fc" fontSize="12">Wound-Wait for deadlock freedom</text>
</svg>

For most OLTP workloads, MutationGuard significantly reduces conflict-related aborts by catching them early, before replication work is done.
