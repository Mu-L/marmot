syntax = "proto3";
package marmot.v2;

option go_package = "github.com/maxpert/marmot/grpc";

// Single gRPC service for all peer communication
service MarmotService {
  // ===== GOSSIP PROTOCOL =====
  // Periodic gossip messages (SWIM-style)
  rpc Gossip(GossipRequest) returns (GossipResponse);

  // Join cluster
  rpc Join(JoinRequest) returns (JoinResponse);

  // Heartbeat/health check
  rpc Ping(PingRequest) returns (PingResponse);

  // ===== REPLICATION =====
  // Replicate transaction (quorum writes)
  rpc ReplicateTransaction(TransactionRequest)
      returns (TransactionResponse);

  // Quorum read
  rpc Read(ReadRequest) returns (ReadResponse);

  // Streaming changes (for catch-up)
  rpc StreamChanges(StreamRequest)
      returns (stream ChangeEvent);

  // Get replication state (for anti-entropy)
  rpc GetReplicationState(ReplicationStateRequest)
      returns (ReplicationStateResponse);

  // ===== SNAPSHOT TRANSFER =====
  // Get snapshot metadata
  rpc GetSnapshotInfo(SnapshotInfoRequest)
      returns (SnapshotInfoResponse);

  // Stream snapshot chunks
  rpc StreamSnapshot(SnapshotRequest)
      returns (stream SnapshotChunk);

  // Get latest transaction IDs per database (for delta sync detection)
  rpc GetLatestTxnIDs(LatestTxnIDsRequest)
      returns (LatestTxnIDsResponse);
}

// ===== GOSSIP MESSAGES =====
message GossipRequest {
  uint64 source_node_id = 1;
  repeated NodeState nodes = 2;
  uint64 incarnation = 3;
}

message GossipResponse {
  repeated NodeState nodes = 1;
}

message NodeState {
  uint64 node_id = 1;
  string address = 2;
  NodeStatus status = 3;
  uint64 incarnation = 4;
  // Schema versions per database (for DDL drift detection)
  // key = database_name, value = schema_version
  map<string, uint64> database_schema_versions = 5;
  // Minimum applied sequence number (watermark for GC coordination)
  uint64 min_applied_seq = 6;
}

enum NodeStatus {
  ALIVE = 0;
  SUSPECT = 1;
  DEAD = 2;
  JOINING = 3;  // Node is catching up, receives gossip but not replication
  REMOVED = 4;  // Node explicitly removed from cluster via admin API
}

message JoinRequest {
  uint64 node_id = 1;
  string address = 2;
}

message JoinResponse {
  bool success = 1;
  repeated NodeState cluster_nodes = 2;
}

message PingRequest {
  uint64 source_node_id = 1;
}

message PingResponse {
  uint64 node_id = 1;
  NodeStatus status = 2;
}

// ===== REPLICATION MESSAGES =====
message TransactionRequest {
  uint64 txn_id = 1;
  uint64 source_node_id = 2;
  repeated Statement statements = 3;
  HLC timestamp = 4;
  // Phase for 2PC protocol
  TransactionPhase phase = 5;
  // Consistency level
  ConsistencyLevel consistency = 6;
  // Target database name
  string database = 7;
  // MutationGuard: table_name -> guard metadata (for multi-row mutations)
  map<string, MutationGuard> mutation_guards = 8;
}

// Per-table mutation guard metadata for conflict detection
// Uses XXH64 hash list for exact conflict detection (no false positives)
//
// Design: Hash List approach provides deterministic conflict detection:
// - ≤64K rows: Send XXH64 hash list (≤512KB payload)
// - >64K rows: Skip MutationGuard, rely on MVCC write intents
//
// This is a novel technique combining:
// - Early batch conflict detection (vs per-row during execution)
// - Compact write set representation (8 bytes/row vs full keys)
// - Coordinator-side detection (vs storage layer)
// - Native leaderless architecture support
message MutationGuard {
  // Number of rows in this mutation
  int64 expected_row_count = 2;
  // XXH64 hashes of affected row keys (8 bytes each, fixed encoding)
  // Empty if row count exceeds max_guard_rows config (default 65536)
  repeated fixed64 key_hashes = 3;
}

enum TransactionPhase {
  PREPARE = 0;  // Phase 1: Create write intents
  COMMIT = 1;   // Phase 2: Commit transaction
  ABORT = 2;    // Abort: Rollback transaction
  REPLAY = 3;   // Anti-entropy replay: Apply already-committed transaction directly
}

enum ConsistencyLevel {
  CONSISTENCY_ONE = 0;
  CONSISTENCY_QUORUM = 1;
  CONSISTENCY_ALL = 2;
}

// Statement represents either a DML row change or a DDL schema change
// Following industry standard CDC approach (MySQL binlog, TiDB TiCDC, CockroachDB)
message Statement {
  StatementType type = 1;
  string table_name = 2;
  string database = 3;  // Target database name (required)

  // Use oneof to clearly separate DML (row changes) from DDL (schema changes)
  oneof payload {
    RowChange row_change = 4;  // For INSERT/UPDATE/DELETE - actual row data
    DDLChange ddl_change = 5;  // For DDL - SQL statement only
  }
}

// Row-level change data (DML operations)
// Follows MySQL binlog row format and TiDB TiCDC approach
message RowChange {
  // Primary key value for MVCC conflict detection
  string row_key = 1;

  // Row images (before/after values)
  // - INSERT: only new_values populated
  // - UPDATE: both old_values and new_values populated (for conflict detection)
  // - DELETE: only old_values populated (or just row_key is sufficient)
  // - REPLACE: old_values for conflict check, new_values for data
  map<string, bytes> old_values = 2;  // Column name -> serialized value (before image)
  map<string, bytes> new_values = 3;  // Column name -> serialized value (after image)
}

// DDL schema change (CREATE/DROP/ALTER)
// DDL operations must ship SQL because schema changes cannot be represented as row data
message DDLChange {
  string sql = 1;  // Transpiled SQLite DDL statement
}

enum StatementType {
  INSERT = 0;
  UPDATE = 1;
  DELETE = 2;
  REPLACE = 3;
  DDL = 4;
  CREATE_DATABASE = 5;
  DROP_DATABASE = 6;
}

message HLC {
  int64 wall_time = 1;
  int32 logical = 2;
  uint64 node_id = 3;
}

message TransactionResponse {
  bool success = 1;
  string error_message = 2;
  HLC applied_at = 3;
  // Write-write conflict detection
  bool conflict_detected = 4;
  string conflict_details = 5;
}

message ReadRequest {
  string query = 1;
  uint64 source_node_id = 2;
  // Snapshot timestamp for MVCC reads
  HLC snapshot_ts = 3;
  // Consistency level
  ConsistencyLevel consistency = 4;
  string table_name = 5;
  // Target database name
  string database = 6;
}

message ReadResponse {
  repeated Row rows = 1;
  HLC timestamp = 2;
}

message Row {
  map<string, bytes> columns = 1;
}

message StreamRequest {
  uint64 from_txn_id = 1;
  uint64 requesting_node_id = 2;
  string database = 3;  // Optional: filter by database, empty = all
  uint64 from_seq_num = 4;  // Optional: request by sequence number (preferred for gap detection)
}

message ChangeEvent {
  uint64 txn_id = 1;
  repeated Statement statements = 2;
  HLC timestamp = 3;
  string database = 4;  // Target database for these changes
  uint64 required_schema_version = 5;  // Minimum schema version required for this transaction
  uint64 seq_num = 6;  // Monotonic sequence number for gap detection
}

message ReplicationStateRequest {
  uint64 requesting_node_id = 1;
  string database = 2;  // Optional: filter by specific database, empty = all
}

message ReplicationStateResponse {
  repeated DatabaseReplicationState states = 1;
}

message DatabaseReplicationState {
  string database_name = 1;
  uint64 last_applied_txn_id = 2;
  HLC last_applied_timestamp = 3;
  int64 last_sync_time = 4;
  string sync_status = 5;  // SYNCED, CATCHING_UP, FAILED
  uint64 current_max_txn_id = 6;  // Latest txn_id in this database
  int64 committed_txn_count = 7;  // Number of committed transactions (for row count comparison)
  uint64 max_seq_num = 8;  // Maximum sequence number for gap detection
}

// ===== SNAPSHOT MESSAGES =====
message SnapshotInfoRequest {
  uint64 requesting_node_id = 1;
}

message SnapshotInfoResponse {
  uint64 snapshot_txn_id = 1;
  int64 snapshot_size_bytes = 2;
  int32 total_chunks = 3;
  HLC timestamp = 4;
  repeated DatabaseFileInfo databases = 5;
}

message DatabaseFileInfo {
  string name = 1;        // Database name (e.g., "marmot", "__marmot_system")
  string filename = 2;    // Relative path
  int64 size_bytes = 3;
  string sha256_checksum = 4;  // SHA256 hex digest for integrity verification
}

message SnapshotRequest {
  uint64 requesting_node_id = 1;
}

message SnapshotChunk {
  int32 chunk_index = 1;
  int32 total_chunks = 2;
  bytes data = 3;
  string checksum = 4;
  string filename = 5;      // Which database file this chunk belongs to
  bool is_last_for_file = 6; // True if this is the last chunk for this file
}

// ===== DELTA SYNC DETECTION =====
message LatestTxnIDsRequest {
  uint64 requesting_node_id = 1;
}

message LatestTxnIDsResponse {
  // Map of database name to latest committed txn_id
  map<string, uint64> database_txn_ids = 1;
}
